(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Stephen Dolan, University of Cambridge                     *)
(*                                                                        *)
(*   Copyright 2014 Stephen Dolan.                                        *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

let pool_words = 4096 (* Number of words in a pool *)
let header_size = 7 (* Wsize_bsize(sizeof(struct pool)) *)
let max_slot = 128 (* maximum whsize stored in pools (SIZECLASS_MAX) *)
let max_overhead = 0.101

(* `overhead pool slot whsize` is the fraction of `pool` which would be wasted
   if slots of size `slot` were used to store blocks of size `whsize` *)

let overhead pool slot whsize =
  let slots = pool / slot in
  (1. -. Float.of_int(slots * whsize) /. Float.of_int pool)

(* Prevention of false sharing requires certain slot sizes to be present. This
   ensures they are generated.

  Runtime has a constructor for atomics (`caml_atomic_make_contended`), which
  aligns them with cache lines to avoid false sharing. The implementation relies
  on the fact that pools are cache-aligned by design and slots of appropriate
  size maintain this property (by padding after the pool header). To be precise,
  slots whose size is a multiple of the cache line size are laid out in such a
  way, that their boundaries coincide with boundaries between cache lines.
*)
let size_required = function
  | 16 | 32 -> true
  | _ -> false

let avail_pool_words = pool_words - header_size

(* `whsize_sizeclass` is the list of actual slot sizes, in ascending order *)

let whsize_sizeclass =
  (* whsize_sizeclass' pool last whsize returns the minimal list of slot sizes
     less than `last` into which `pool` words can be divided, such that:
     - the required slot sizes are included in the list;
     - the overhead does not exceed `max_overhead` *)
  let rec whsize_sizeclass' pool last = function
    | 0 -> []
    | whsize ->
      if overhead pool last whsize > max_overhead
      || size_required whsize
      then
        if overhead pool whsize whsize < max_overhead then
          whsize :: whsize_sizeclass' pool whsize (whsize - 1)
        else
          failwith
            (Format.sprintf
               "%d-word blocks won't fit in %d-word pool below %.1f%% overhead"
               whsize pool (100. *. max_overhead))
      else whsize_sizeclass' pool last (whsize - 1)
  in
  List.rev (whsize_sizeclass' avail_pool_words max_int max_slot)

(* sizeclass_whsize is the list of indexes into `whsize_sizeclass` for
   allocating objects of all whsizes from 0 up to and including
   `max_slot`. There's a dummy value 255 for whsize 0 *)
let sizeclass_whsize =
  let rec sizeclass_whsize' whsize =
    if whsize > max_slot then
      []
    else
      match List.find_index (fun slot -> whsize <= slot) whsize_sizeclass with
      | Some i -> i :: sizeclass_whsize' (whsize + 1)
      | None -> raise Not_found
  in 255 :: (sizeclass_whsize' 1)

(* padding_sizeclass is a list giving the number of words of padding which
   must be placed after the pool header when siots are the corresponding
   size from `whsize_sizeclass` *)
let padding_sizeclass =
  whsize_sizeclass |> List.map (fun slot -> avail_pool_words mod slot)

(* wfrag_whsize is a list giving the number of words left as a fragment when a
   block of given whsize is allocated. There's a dummy value 255 for whsize
   0 *)
let wfrag_whsize =
  255 :: ((List.tl sizeclass_whsize)
          |> List.mapi (fun n s -> (List.nth whsize_sizeclass s - n - 1)))

open Format

(*

   (* Sanity-check code *)

   let rec print_overheads n = function
     | [] -> ()
     | s :: ss when n > s -> print_overheads n ss
     | (s :: _) as ss  ->
        printf "%3d/%-3d: %.1f%%\n" n s (100. *. overhead avail_pool_words s n);
        print_overheads (n+1) ss

      let () = print_overheads 1 whsize_sizeclass

*)

let rec print_list ppf = function
  | [] -> ()
  | [x] -> fprintf ppf "%d" x
  | x :: xs -> fprintf ppf "%d,@ %a" x print_list xs

let _ =
  printf {|/* This file is generated by tools/gen_sizeclasses.ml */
#ifndef CAML_SIZECLASSES_H
#define CAML_SIZECLASSES_H

#include <assert.h>
#include <limits.h>
|};
  printf {|
#define POOL_WSIZE %d
#define POOL_HEADER_WSIZE %d
#define SIZECLASS_MAX %d
#define NUM_SIZECLASSES %d
|}
    pool_words header_size max_slot (List.length whsize_sizeclass);
  printf {|
typedef unsigned char sizeclass_t;
static_assert(NUM_SIZECLASSES < (1 << (CHAR_BIT * sizeof(sizeclass_t))), "");

/* The slot sizes (and therefore the largest whsize) for each size class.
   (A gap is left after smaller objects) */
static const unsigned int whsize_sizeclass[NUM_SIZECLASSES] =@[<2>{ %a };@]
|}
    print_list whsize_sizeclass;
  printf {|
/* The number of padding words to use, at the beginning of a pool
   of each sizeclass, to reach exactly POOL_WSIZE words. */
static const unsigned char padding_sizeclass[NUM_SIZECLASSES] =@[<2>{ %a };@]
|}
    print_list padding_sizeclass;
  printf {|
/* The size class (index into whsize_sizeclass) for each
   whsize from 0 to SIZECLASS_MAX. Dummy value 255 at index 0. */
static const sizeclass_t sizeclass_whsize[SIZECLASS_MAX + 1] =@[<2>{ %a };@]
|}
    print_list sizeclass_whsize;
  printf {|
/* The number of free words left in the slot after a block of each whsize from
   0 to SIZECLASS_MAX. Dummy value 255 at index 0. */
static const mlsize_t wfrag_whsize[SIZECLASS_MAX + 1] =@[<2>{ %a };@]
|}
    print_list wfrag_whsize;
  printf {|
#endif /* CAML_SIZECLASSES_H */
|}
